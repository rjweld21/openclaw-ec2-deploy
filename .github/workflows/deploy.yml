# GitHub Actions workflow for OpenClaw EC2 deployment
# FIXED: Added concurrency controls to prevent parallel executions
# FIXED: Improved job dependencies and state management

name: Deploy OpenClaw to EC2

on:
  push:
    branches: [main, staging, develop]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

# ğŸ”§ FIX: Add concurrency control to prevent parallel builds
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}
  cancel-in-progress: false  # Don't cancel running deployments, queue them instead

# Explicit permissions for GITHUB_TOKEN
permissions:
  contents: read
  pull-requests: write
  issues: write
  id-token: write  # For OIDC authentication with AWS

# Environment variables
env:
  TF_VERSION: "1.6.0"
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"
  AWS_DEFAULT_REGION: ${{ vars.AWS_DEFAULT_REGION || 'us-east-1' }}

jobs:
  validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    outputs:
      tf-fmt: ${{ steps.fmt.outputs.exitcode }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Avoid wrapper issues with outputs

      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init (validation only)
        run: terraform init -backend=false

      - name: Terraform Validate
        run: terraform validate

      - name: Comment PR - Validation Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fmt = '${{ steps.fmt.outputs.exitcode }}';
            const fmtStatus = fmt === '0' ? 'âœ… Passed' : 'âŒ Failed';
            
            const output = `### Terraform Validation Results
            
            | Check | Status |
            |-------|--------|
            | Format | ${fmtStatus} |
            | Validate | âœ… Passed |
            
            ${fmt !== '0' ? 'âš ï¸ **Format check failed!** Run `terraform fmt -recursive` to fix.' : ''}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    environment: 
      name: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}
    env:
      TF_VAR_environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: terraform-${{ github.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Configure AWS credentials (Access Keys)
        if: vars.AWS_ROLE_ARN == ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Verify AWS credentials
        run: |
          aws sts get-caller-identity
          echo "AWS Region: $(aws configure get region)"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      # ğŸ”§ FIX: Add state lock check before proceeding
      - name: Check for existing locks
        run: |
          echo "Checking for existing Terraform state locks..."
          # This will be handled by the concurrency group, but adding visibility
          echo "Concurrency group: ${{ github.workflow }}-${{ env.TF_VAR_environment }}"

      - name: Create Terraform variables file
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_DEFAULT_REGION }}"
          environment = "${{ env.TF_VAR_environment }}"
          project_name = "openclaw"
          
          # Instance configuration
          instance_type = "${{ vars.INSTANCE_TYPE || 't3.medium' }}"
          min_size = ${{ vars.MIN_SIZE || 1 }}
          max_size = ${{ vars.MAX_SIZE || 3 }}
          desired_capacity = ${{ vars.DESIRED_CAPACITY || 2 }}
          
          # Networking
          vpc_cidr = "${{ vars.VPC_CIDR || '10.0.0.0/16' }}"
          
          # Security
          key_pair_name = "${{ vars.KEY_PAIR_NAME || '' }}"
          ssl_certificate_arn = "${{ vars.SSL_CERTIFICATE_ARN || '' }}"
          
          # Features
          enable_load_balancer = ${{ vars.ENABLE_LOAD_BALANCER || 'true' }}
          enable_cloudwatch_monitoring = ${{ vars.ENABLE_MONITORING || 'true' }}
          
          # OpenClaw configuration
          openclaw_version = "${{ vars.OPENCLAW_VERSION || 'latest' }}"
          openclaw_port = ${{ vars.OPENCLAW_PORT || 8080 }}
          
          # Additional tags
          additional_tags = {
            "DeployedBy" = "github-actions"
            "Repository" = "${{ github.repository }}"
            "Branch" = "${{ github.ref_name }}"
            "CommitSha" = "${{ github.sha }}"
            "BuildId" = "${{ github.run_id }}"
          }
          EOF

      - name: Terraform Init
        run: |
          # Handle backend configuration based on environment
          if [ "${{ env.TF_VAR_environment }}" = "prod" ]; then
            terraform init \
              -backend-config="bucket=${{ vars.TF_STATE_BUCKET || 'openclaw-terraform-state' }}" \
              -backend-config="key=openclaw-ec2/prod/terraform.tfstate" \
              -backend-config="region=${{ env.AWS_DEFAULT_REGION }}" \
              -backend-config="dynamodb_table=${{ vars.TF_STATE_LOCK_TABLE || 'openclaw-terraform-locks' }}"
          else
            terraform init \
              -backend-config="bucket=${{ vars.TF_STATE_BUCKET || 'openclaw-terraform-state' }}" \
              -backend-config="key=openclaw-ec2/${{ env.TF_VAR_environment }}/terraform.tfstate" \
              -backend-config="region=${{ env.AWS_DEFAULT_REGION }}" \
              -backend-config="dynamodb_table=${{ vars.TF_STATE_LOCK_TABLE || 'openclaw-terraform-locks' }}"
          fi

      - name: Terraform Plan
        id: plan
        run: |
          set +e  # Don't exit on error to capture exit code
          terraform plan -detailed-exitcode -out=tfplan
          PLAN_EXIT_CODE=$?
          
          # Store plan output for commenting
          terraform show -no-color tfplan > plan.txt
          
          echo "exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "No changes needed"
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "Changes planned"
          else
            echo "Plan failed with exit code $PLAN_EXIT_CODE"
            exit $PLAN_EXIT_CODE
          fi

      - name: Upload plan file
        if: steps.plan.outputs.exit_code == '2'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.TF_VAR_environment }}
          path: |
            tfplan
            plan.txt
            terraform.tfvars
          retention-days: 30

      - name: Comment PR - Plan Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const exitCode = '${{ steps.plan.outputs.exit_code }}';
            
            let planOutput = '';
            try {
              planOutput = fs.readFileSync('plan.txt', 'utf8');
            } catch (error) {
              planOutput = 'Could not read plan output';
            }
            
            // Truncate output if too long
            if (planOutput.length > 60000) {
              planOutput = planOutput.substring(0, 60000) + '\n\n... (truncated)';
            }
            
            const planStatus = exitCode === '0' ? 'âœ… No changes' : 
                              exitCode === '2' ? 'ğŸ“‹ Changes planned' : 'âŒ Failed';
            
            const output = `### Terraform Plan Results - ${{ env.TF_VAR_environment }}
            
            **Status:** ${planStatus}
            **Exit Code:** ${exitCode}
            
            <details>
            <summary>ğŸ“‹ Plan Output</summary>
            
            \`\`\`hcl
            ${planOutput}
            \`\`\`
            
            </details>
            
            ${exitCode === '2' ? 'âš ï¸ **This plan requires approval before applying.**' : ''}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  deploy:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: validate
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.ref == 'refs/heads/staging' && github.event_name == 'push') ||
      (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    environment: 
      name: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}
      url: ${{ steps.apply.outputs.application_url }}
    env:
      TF_VAR_environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'prod') || (github.ref == 'refs/heads/staging' && 'staging') || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ğŸ”§ FIX: Add build status notification
      - name: Notify deployment start
        run: |
          echo "ğŸš€ Starting deployment for environment: ${{ env.TF_VAR_environment }}"
          echo "ğŸ”’ This build is protected by concurrency group: ${{ github.workflow }}-${{ env.TF_VAR_environment }}"
          echo "ğŸ“ Build ID: ${{ github.run_id }}"

      - name: Configure AWS credentials (OIDC)
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: terraform-${{ github.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Configure AWS credentials (Access Keys)
        if: vars.AWS_ROLE_ARN == ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Create Terraform variables file
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_DEFAULT_REGION }}"
          environment = "${{ env.TF_VAR_environment }}"
          project_name = "openclaw"
          
          # Instance configuration
          instance_type = "${{ vars.INSTANCE_TYPE || 't3.medium' }}"
          min_size = ${{ vars.MIN_SIZE || 1 }}
          max_size = ${{ vars.MAX_SIZE || 3 }}
          desired_capacity = ${{ vars.DESIRED_CAPACITY || 2 }}
          
          # Networking
          vpc_cidr = "${{ vars.VPC_CIDR || '10.0.0.0/16' }}"
          
          # Security
          key_pair_name = "${{ vars.KEY_PAIR_NAME || '' }}"
          ssl_certificate_arn = "${{ vars.SSL_CERTIFICATE_ARN || '' }}"
          
          # Features
          enable_load_balancer = ${{ vars.ENABLE_LOAD_BALANCER || 'true' }}
          enable_cloudwatch_monitoring = ${{ vars.ENABLE_MONITORING || 'true' }}
          
          # OpenClaw configuration
          openclaw_version = "${{ vars.OPENCLAW_VERSION || 'latest' }}"
          openclaw_port = ${{ vars.OPENCLAW_PORT || 8080 }}
          
          # Additional tags
          additional_tags = {
            "DeployedBy" = "github-actions"
            "Repository" = "${{ github.repository }}"
            "Branch" = "${{ github.ref_name }}"
            "CommitSha" = "${{ github.sha }}"
            "BuildId" = "${{ github.run_id }}"
          }
          EOF

      - name: Terraform Init
        run: |
          if [ "${{ env.TF_VAR_environment }}" = "prod" ]; then
            terraform init \
              -backend-config="bucket=${{ vars.TF_STATE_BUCKET || 'openclaw-terraform-state' }}" \
              -backend-config="key=openclaw-ec2/prod/terraform.tfstate" \
              -backend-config="region=${{ env.AWS_DEFAULT_REGION }}" \
              -backend-config="dynamodb_table=${{ vars.TF_STATE_LOCK_TABLE || 'openclaw-terraform-locks' }}"
          else
            terraform init \
              -backend-config="bucket=${{ vars.TF_STATE_BUCKET || 'openclaw-terraform-state' }}" \
              -backend-config="key=openclaw-ec2/${{ env.TF_VAR_environment }}/terraform.tfstate" \
              -backend-config="region=${{ env.AWS_DEFAULT_REGION }}" \
              -backend-config="dynamodb_table=${{ vars.TF_STATE_LOCK_TABLE || 'openclaw-terraform-locks' }}"
          fi

      - name: Terraform Apply
        id: apply
        run: |
          terraform apply -auto-approve
          
          # Capture outputs
          APPLICATION_URL=$(terraform output -raw application_url 2>/dev/null || echo "Not available")
          LOAD_BALANCER_DNS=$(terraform output -raw load_balancer_dns_name 2>/dev/null || echo "Not available")
          
          echo "application_url=$APPLICATION_URL" >> $GITHUB_OUTPUT
          echo "load_balancer_dns=$LOAD_BALANCER_DNS" >> $GITHUB_OUTPUT

      # ğŸ”§ FIX: Enhanced health check for port 8080
      - name: Wait for deployment readiness (Port 8080)
        if: steps.apply.outputs.application_url != 'Not available'
        run: |
          echo "ğŸ¥ Waiting for OpenClaw Gateway on port 8080..."
          
          MAX_ATTEMPTS=30
          ATTEMPT=1
          APPLICATION_URL="${{ steps.apply.outputs.application_url }}"
          
          # Test both potential health endpoints
          HEALTH_URLS=(
            "${APPLICATION_URL}/health"
            "${APPLICATION_URL}:8080/health"
            "${APPLICATION_URL}:8080/"
          )
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "ğŸ” Attempt $ATTEMPT/$MAX_ATTEMPTS"
            
            for HEALTH_URL in "${HEALTH_URLS[@]}"; do
              echo "   Testing: $HEALTH_URL"
              if curl -sf --connect-timeout 10 "$HEALTH_URL" > /dev/null 2>&1; then
                echo "âœ… OpenClaw Gateway is ready at: $HEALTH_URL"
                echo "SUCCESSFUL_HEALTH_URL=$HEALTH_URL" >> $GITHUB_ENV
                exit 0
              fi
            done
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
              echo "ğŸ”§ Security group may need port 8080 opened"
              exit 1
            fi
            
            echo "â³ Waiting 30 seconds before next attempt..."
            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Create deployment summary
        if: always()
        run: |
          cat > $GITHUB_STEP_SUMMARY << 'EOF'
          # ğŸš€ OpenClaw Deployment Summary
          
          **Environment:** ${{ env.TF_VAR_environment }}  
          **Region:** ${{ env.AWS_DEFAULT_REGION }}  
          **Status:** ${{ job.status }}  
          **Commit:** ${{ github.sha }}
          **Build ID:** ${{ github.run_id }}
          
          ## ğŸ“Š Deployment Details
          
          | Resource | Value |
          |----------|-------|
          | Application URL | ${{ steps.apply.outputs.application_url }} |
          | Load Balancer DNS | ${{ steps.apply.outputs.load_balancer_dns }} |
          | Health Check | ${{ env.SUCCESSFUL_HEALTH_URL || 'Not available' }} |
          | OpenClaw Port | 8080 |
          
          ## ğŸ” Concurrency Protection
          
          - **Concurrency Group:** `${{ github.workflow }}-${{ env.TF_VAR_environment }}`
          - **Parallel Builds:** Prevented âœ…
          - **State Locking:** DynamoDB managed
          
          ## ğŸ”— Useful Links
          
          - [AWS Console](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_DEFAULT_REGION }})
          - [CloudWatch Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_DEFAULT_REGION }}#logsV2:log-groups)
          - [Auto Scaling Groups](https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_DEFAULT_REGION }}#AutoScalingGroups:)
          
          ## â­ï¸ Next Steps
          
          1. âœ… Verify OpenClaw Gateway at port 8080
          2. ğŸ” Check CloudWatch metrics and logs  
          3. ğŸŒ Configure DNS records if needed
          4. ğŸ“Š Set up monitoring alerts
          5. ğŸ”’ Verify security group allows port 8080
          EOF

  destroy:
    name: Terraform Destroy
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    environment: 
      name: ${{ github.event.inputs.environment }}
    env:
      TF_VAR_environment: ${{ github.event.inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: terraform-destroy-${{ github.run_id }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Configure AWS credentials (Access Keys)
        if: vars.AWS_ROLE_ARN == ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Create minimal Terraform variables file
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_DEFAULT_REGION }}"
          environment = "${{ env.TF_VAR_environment }}"
          project_name = "openclaw"
          EOF

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TF_STATE_BUCKET || 'openclaw-terraform-state' }}" \
            -backend-config="key=openclaw-ec2/${{ env.TF_VAR_environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_DEFAULT_REGION }}" \
            -backend-config="dynamodb_table=${{ vars.TF_STATE_LOCK_TABLE || 'openclaw-terraform-locks' }}"

      - name: Terraform Destroy
        run: terraform destroy -auto-approve